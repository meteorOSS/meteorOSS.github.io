<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="zsh-blog"><title>树与二叉树 | meteor(zsh)</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">树与二叉树</h1><a id="logo" href="/.">meteor(zsh)</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 简历</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">树与二叉树</h1><div class="post-meta">2023-02-01<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>::: hljs-center</p>
<p><font size='20' color='green'><strong>树与二叉树</strong></font></p>
<p>:::<br>&lt;树，二叉树结构&gt; 笔记目录</p>
<blockquote>
<p><a target="_blank" rel="noopener" href='http://www.zsenhe.com/article/87'>0. 树与二叉树</a><br><a target="_blank" rel="noopener" href='http://www.zsenhe.com/article/89'>1. 二叉树的定义与存储</a><br><a target="_blank" rel="noopener" href='http://www.zsenhe.com/article/90'>2.二叉树的遍历</a></p>
</blockquote>
<hr>

<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>查找指的是根据某个给定关键词K，从集合R中找出关键字与K相同的记录，查找分为两类</p>
<p><strong>静态查找</strong>: 集合中<font color='red'><strong>记录是固定</strong></font>的，没有插入删除操作，只有查找<br><strong>动态查找</strong>: 集合中<font color='red'><strong>记录是动态变化</strong></font>的，除查找外还可能发生插入与删除操作</p>
<p><em>举个例子，一本词典中可能有成万上百万的单词，当它印刷成书的时候集合是不变的，我们经常需要进行单词的查阅，这就是所谓静态查找了;而动态查找可能发生在某个百科网站上，当我们检索条目的同时可能也有一些过时的资料被清除更新</em></p>
<p>我们的一般表示方法是把数据放在数组里面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">	<span class="type">int</span> data[<span class="number">1001</span>];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> LNode * L;</span><br></pre></td></tr></table></figure>
<p>顺序查找这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTarget</span><span class="params">(L l,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	l-&gt;data[<span class="number">0</span>] = target; <span class="comment">//建立哨兵 </span></span><br><span class="line">	<span class="keyword">for</span>(i = l-&gt;length;l-&gt;data[i]!=target;i--);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>哨兵?这是什么新术语</strong></p>
<p>它的存在是为了少写一些边界判断的逻辑，我们定义一个“哨兵”将它存放在数组下标为0的位置，这样当循环退出时，i为0自然就是未找到了;于是我们知道接收到0的时候，就是元素不存在于数组中，当然这样实现的话，插入元素时需注意合法下标在 <strong>[1,n)</strong><br>它的时间复杂度是 <font color='blue'> <strong>O(N)</strong> </font></p>
<hr>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>顺序查找的效率显然是极低的。我们可以使用二分查找（也叫折半查找）,它并不是生面孔，平常的聚会游戏也会经常用到，没有任何的改变<br>假设n个数据元素的关键字满足有序（降序 升序）并且连续存放,代码长这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(L l,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> left,right,mid,NF = <span class="number">-1</span>;</span><br><span class="line">	left = <span class="number">1</span>;<span class="comment">//初始化左边界 </span></span><br><span class="line">	right = l-&gt;length; <span class="comment">//初始化右边界 </span></span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right)&#123; </span><br><span class="line">		mid = (left+right)/<span class="number">2</span>; <span class="comment">//计算中间元素坐标 </span></span><br><span class="line">		<span class="keyword">if</span>(target&lt;l-&gt;data[mid])  right=mid<span class="number">-1</span>; <span class="comment">//调整右边界 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;l-&gt;data[mid]) left = mid+; <span class="comment">//调整左边界 </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NF; <span class="comment">//未查找成功，返回-1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次查找都缩小一半范围，实际意义即是n &#x3D; n&#x2F;2，根据公式知道除以logn次后归1，于是它的时间复杂度为 <font color='blue'> <strong>O(logn)</strong> </font><br>通过事先对数据进行排序，可以让我们的查找效率大大提高<br>对于二分查找的解题思路，这里有一篇很详细的笔记： <a target="_blank" rel="noopener" href="http://www.zsenhe.com/article/8">二分查找的思想和解题步骤笔记，模板</a></p>
<hr>
## 二分查找的启示

<p>为什么二分查找就快呢？通过事先排好序，实际上我们已经构建了它的查找顺序;我们可以构造出这样的一棵树来表述<br><img src="http://cdn.zsenhe.com/b3c4e5d7754f408ca96f93263e303b2b" alt="image.png"></p>
<p>对于从1开始的这样11个元素，只要排好序了，那么第一次比较的一定是下标为6这个元素，根据查找的值来决定往左节点走还是右节点走，对于6这个位置，如果比较值元素比l[6]大，那么下一次将往右节点9走….以此类推</p>
<p>而元素的查找次数便是所在的层数,例如4这个节点是要寻找的值，它位于第三层，比较三次后就可以取出;树的总层次是logn+1,+1是为了取整;<strong>树的深度有<font color='blue'>logn+1</font>层</strong></p>
<p>考虑它的平均查找次数,树总共有4层</p>
<blockquote>
<p>查找4次总共有4种情况,查找3次4种情况,查找2次2种情况，查找1次只有1种情况（l[6]&#x3D;&#x3D;target）</p>
</blockquote>
<p>那么它的平均查找成功次数 <font color='blue'>ASL &#x3D; (4*4+4*3+2*3+1)&#x2F;11 &#x3D; 3</font><br>综上所述，由于我们在数组里面对查找的元素进行了有序化的组织，使得查找过程按照固定的顺序进行，而顺序形成了类似树的结构;那反过来说，我们能不能按照这一种树的结构来存储数据，能不能达到二分查找的要求?这就是<strong>查找树</strong>了，在效率上它可以和二分查找达到同样logn，同时它在插入数据时，比存储在数组中方便的多</p>
<p>以查找树的形式存储，可以很好的解决顺序查找的第二大类问题 <strong>动态查找问题</strong></p>
<hr>

<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p><font color='blue'><strong>树(Tree)</strong></font>: n (n&gt;&#x3D;0) 个节点构成的有限集合。<br>当n&#x3D;0时，称为 <font color='blue'><strong>空树</strong></font>;<br>对于任一<font color='blue'><strong>非空树</strong>(n&gt;0)</font>，它具备以下性质:</p>
<blockquote>
<p>树中有一个称为<font color='red'><strong>根(root)</strong></font>的特殊节点,用r表示<br>其余节点可分为<font color='red'><strong>m(m&gt;0)</strong></font>个互不相交的有限集T1,T2…Tm,其中每个集合本身又是一棵树，称为原来树的<font color='blue'><strong>子树(SubTree)</strong></font></p>
</blockquote>
<p><img src="http://cdn.zsenhe.com/9a4e8e7ba8b34676a107b9ad934331da" alt="image.png"><br>树的定义采用了递归的设计，例如A是由下一层的四棵子树构成，每个子树又是一棵树</p>
<hr>

<h3 id="树与非树"><a href="#树与非树" class="headerlink" title="树与非树"></a>树与非树</h3><p><img src="http://cdn.zsenhe.com/f770e16faafc43bd896645a76dd39c27" alt="image.png"><br>如图，这样的结构为什么不能称之为树呢?前面提到了树的子树之间是不相交的，如图1由于C与D之间连着线，我们无法做到把他们切割开来</p>
<p>现在明确一下树的更多概念</p>
<blockquote>
<p>1.子树是<strong>不相交</strong>的<br>2.除了根节点以外，每个节点<strong>有且仅有一个父节点</strong><br>3.一颗N个节点的树有<strong>N-1条边</strong><br>（因为每个节点都有一条通往父节点的线，root除外）</p>
</blockquote>
<p>树是保证节点联通的最小的一种连接方式;即边最少的一种方式</p>
<h3 id="树的一些基本术语"><a href="#树的一些基本术语" class="headerlink" title="树的一些基本术语"></a>树的一些基本术语</h3><ol>
<li><strong>节点的度(Degree)</strong>: 节点的子树个数</li>
<li><strong>树的度</strong>: 树的所有节点中最大的度数</li>
<li><strong>叶节点(Leaf)</strong>: 度为0的结点</li>
<li><strong>父节点(Parent)</strong>: 有子树的结点是其子树根节点的父节点</li>
<li><strong>子节点(Child)</strong>: 若A节点是B节点的父节点，则称B节点是A节点的子节点;子节点也称孩子节点</li>
<li><strong>兄弟节点(Sibling)</strong>: 两个节点具有同一父节点，即称之为兄弟节点</li>
<li><strong>路径和路径长度</strong>: 从节点N1到Nk的路径称之为一个节点序列(N1,N2…Nk-1,Nk),Ni是Ni+1的父节点。路径中包含的边数称为路径长度</li>
<li><strong>祖先节点</strong>: 沿树根到某一节点路径上的所有节点都称为这个节点的祖先节点</li>
<li><strong>子孙节点</strong>: 某一节点的子树中的所有节点都称之为这个节点的子孙节点</li>
<li><strong>节点的层次</strong>: 规定根节点在1层，其他任一节点的层数是其父节点的层数+1</li>
<li><strong>树的深度</strong>: 树中所有节点中的最大层次是这棵树的深度</li>
</ol>
<p>大多数概念类似家谱系中的表示，完全可以用常识去理解加深印象</p>
<hr>

<h2 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h2><p>考虑前面所学的知识，树能不能使用链表或者数据来实现呢？首先考虑数组，这样难度还是较大的，因为树中存在着很多形式，任何一个节点可能都有一个或多个儿子;我们很难判断一个节点的父节点是谁,儿子是谁</p>
<p>如果用链表来实现呢?它可能会长这样<br><img src="http://cdn.zsenhe.com/bd1b5b686c24403d88c0fb2045f78e63" alt="image.png"><br>每个节点使用一个结构来表示,好像是没问题的,完全可以用结构加指针来表示一棵树?仔细观察,这种方式也是不完美的,如A节点有三个子节点,而B有两个子节点,他们的结构是不一样的,无法做到统一;结构的形式不一样会对程序设计带来困难，毕竟我们访问一个节点时，是无法事先知道他的子节点数量的</p>
<p>另外一种途径呢?把所有的节点设计成一样的结构,例如图中,树的度是3,那我们统一节点的结构,让每个节点都拥有3个指针不就行了,空的就指向NULL</p>
<p>这样解决带来了新的问题,如果这棵树有n个节点,那代表着每个节点拥有3个指针域,这意味着整个树拥有3n个指针;而树只有n-1条边,也就是说只有n-1个指针是非0的,这意味着会有2n+1个指针指向NULL,造成空间浪费</p>
<hr>

<h3 id="儿子-兄弟表示法"><a href="#儿子-兄弟表示法" class="headerlink" title="儿子-兄弟表示法"></a>儿子-兄弟表示法</h3><p>这是一种更好的表示方法，称之为: <font color='blue'><strong>儿子-兄弟表示法</strong></font></p>
<p>它每个节点的结构如下:<br><img src="http://cdn.zsenhe.com/b1c416e1318b4c288bfe944018be21b8" alt="image.png"></p>
<p><strong>FirstChild</strong> 指向了它的下一个子节点; <strong>NextSibling</strong> 指向下一个兄弟节点。以此来把整棵树串起来</p>
<p><img src="http://cdn.zsenhe.com/439001000a1e4612ba80afee0776d352" alt="image.png"></p>
<p>这样的表示方法使得树中的每个节点结构都是统一的且不会造成空间浪费(n+1个指针是空的)</p>
<p>将右图旋转45°得到:<br><img src="http://cdn.zsenhe.com/ef891c74be1a4173a234f734e904cdc2" alt="image.png"><br>形成一棵“树”，可以看到每个节点都有两个指针，最多有两个儿子，这种树称之为 二叉树 ;即树的度为2<br>综上，不管怎样的树结构，我们都可以用儿子-兄弟表示法，将它用二叉树链表的形式实现</p>
<p>所以，当我们想研究一般树的表示与操作的实现，如果我们搞清楚了二叉树的表示与实现，便解决了大部分问题;所以<strong>二叉树是树结构研究里面最重要最主要的内容</strong></p>
<p>引用&amp;参考:<br><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">树,数据结构[维基百科]</a></p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功！"></script><a class="pos-f tr3" id="github" href="https://github.com/meteorOSS" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/alipay.png"></li><li id="WeChat" qr="/img/wechatqrcode.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>树与二叉树</p><p><span>文章作者：</span>meteor</p><p><span>发布时间：</span>2023-02-01</p><p><span>最后更新：</span>2023-02-01</p><p><span>原始链接：</span><a href="/2023/02/01/树与二叉树/">http://blog.zsenhe.com/2023/02/01/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="http://blog.zsenhe.com/2023/02/01/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="http://blog.zsenhe.com/2023/02/01/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cltjxfwhi001ii4v11gwv1z1o" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACwElEQVR42u3aQU4DMRAEQP7/aZA4IUGW7pl1kkPtKSKR1+WDbXrm4yN+Pr+fn59/P49+n4z26DfXb7ntwcPDwxtN/Xq460nMfnP9lvzbf5YADw8P7xgvPwySl12Pn2z0yRuv54yHh4f3DrwEk8PyS/PsoMLDw8N7B1679ed/yZF4eHh478NLwohZNLAJapP53Ja14OHh4XXvqgtgr/18vL6Hh4eHN6qqzzbl6wltClr1bPHw8PAO8PLgII8kZtt6u1h5sIuHh4d3L68tYuULkUQJm5lE4+Ph4eEd5rWRaH48tIdHUhiLqHh4eHgHeG1RKmkdmB0Dm8MjmSEeHh7eCd5dx8Cs/N+2UtWFMTw8PLybeO0Ftz0G9hf0VXMDHh4e3mFevkG3Dab7C3QbJePh4eGd483aodqhZw0Bs0Uc9tvi4eHhxbzNP//5b2atWvlyPBwNDw8P7wAvPyTyGlp+Is0OiTx6xsPDw3sVLy+PbSKJNvAdVvnw8PDwjvE2G3de6MqPljxcrnsl8PDw8Ere7Po7a4Fq2W0B7I+54eHh4R3gtU2ls0MiH3PT3hoVw/Dw8PDWvLyAlIe5J6KH4dLj4eHhHeDlHUptnpGErTmyTVbw8PDwnsPL44M8Tj0R5h6s8uHh4eEFvFn7VLIRz8pXyYIWDVh4eHh4x3jt5v5ZPu108+vyP+Pj4eHhHeBtXtAW9dtLdttiFVX28PDw8Na8zVaex7KbWKFdmlW7Kh4eHt6C1wYQs1g2X9C2GeuGuz8eHh5eV52PWgH2vPaaXscQeHh4eMd4yZadN562rahtiStvhMXDw8M7zbutYD+abtv4VTQf4OHh4b2Ul1yp81ihLZvlLQV4eHh478lLNu7kWjxLR4rrOB4eHt4xXhJGtJfjWTvCLETGw8PDeyav3YhnBa1Z2Wx2/Kzqe3h4eHhX334B6SX5PureeygAAAAASUVORK5CYII=">分享</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2023/02/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AD%98%E5%82%A8/">二叉树的定义与存储</a><a class="next" href="/2023/01/30/%E9%98%9F%E5%88%97%E4%B8%8E%E9%A1%BA%E7%8E%AF%E9%98%9F%E5%88%97/">队列与顺环队列</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: 'fc8322a9d1f9189c3ef4',
  clientSecret: '7751271047d80dd7010063d51400bbbcb9dd3e69',
  repo: 'meteorOSS.github.io',
  owner: 'meteoross',
  admin: ['meteoross'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.zsenhe.com"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="简历"><img class="nofancybox" src="/img/avatar.png"/></a><p>我躺在柔软的床上冥想着没有时间的空间</p><a class="info-icon" href="https://twitter.com/username" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:zhengsenhe1027@126.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/meteorOSS" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/20/Apache%20POI%E5%BA%93%E6%89%93%E5%8C%85%E4%B8%BAjar%E5%90%8E%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99/">apache poi库解析报错;java.io.IOException: Your InputStream was neither an OLE2 stream, nor an OOXML str</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/07/hello-world/">我将博客迁移到了这里</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/05/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E8%BD%BD%E5%85%A5%E4%BE%9D%E8%B5%96/">运行时动态载入依赖</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/29/GoReplaceTool%20%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E7%9B%AE%E5%BD%95%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%B7%A5%E5%85%B7/">GoReplaceTool 指定目标目录批量替换工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/26/XPath%E4%B8%8EMyBatis%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97XPathParser/">XPath与MyBatis解析器模块XPathParser</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/26/XML%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/">XML常见的解析方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/06/%E4%B8%80%E5%9D%97%E9%92%B1%E6%8E%89%E5%9C%B0%E4%B8%8A%EF%BC%8C%E7%A2%8E%E6%88%90%E4%BA%86%E4%B8%A4%E5%BC%A0%E4%BA%94%E6%AF%9B/">一块钱掉地上，碎成了两张五毛</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/10/%E8%AF%A5%E6%AD%BB%E7%9A%84%E5%8F%8D%E5%B0%84%E8%AF%A5%E6%AD%BB%E7%9A%84%E5%8F%8D%E5%B0%84%E8%AF%A5%E6%AD%BB%E7%9A%84%E5%8F%8D%E5%B0%84%E8%AF%A5%E6%AD%BB%E7%9A%84%E5%8F%8D%E5%B0%84%E8%AF%A5%E6%AD%BB%E7%9A%84%E5%8F%8D%E5%B0%84/">该死的反射该死的反射该死的反射该死的反射该死的反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/31/%E5%9F%BA%E4%BA%8E%E7%88%B1%E5%8F%91%E7%94%B5%E7%9A%84spigot%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%85%85%E5%80%BC%E5%8F%91%E8%B4%A7/">基于爱发电的spigot服务器自动充值发货</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/08/25/CMS%E4%B8%8E%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/">CMS与三色标记算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/meteorOSS/wechat-bc" title="wechat-bc(类似开发公众号一样，开发个人微信号)" target="_blank">wechat-bc(类似开发公众号一样，开发个人微信号)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">meteor(zsh).</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>